/// Hyoga generated file.
const std = @import("std");
const hy = @import("../root.zig");
const hym = hy.math;
pub const ProcTable = extern struct {
    hy_init: *const fn () callconv(.c) *hy.Engine,
    hy_engine_gameAllocator: *const fn (engine: *hy.Engine) callconv(.c) hy.ExternAllocator,
    hy_engine_gpu: *const fn (engine: *hy.Engine) callconv(.c) *hy.gfx.Gpu,
    hy_engine_input: *const fn (engine: *hy.Engine) callconv(.c) *hy.input.Context,
    hy_engine_phys2: *const fn (engine: *hy.Engine) callconv(.c) *hy.p2.Context,
    hy_engine_ui: *const fn (engine: *hy.Engine) callconv(.c) *hy.UI,
    hy_engine_window: *const fn (engine: *hy.Engine) callconv(.c) *hy.Window,
    hy_audio_soundRead: *const fn (path: hy.ExternSliceConst(u8)) callconv(.c) hy.Audio.Sound,
    hy_audio_soundPlay: *const fn (sound: *hy.Audio.Sound) callconv(.c) void,
    hy_audio_soundStop: *const fn (sound: *hy.Audio.Sound) callconv(.c) void,
    hy_gfx_clearColorSet: *const fn (gpu: *hy.gfx.Gpu, color: hym.Vec4) callconv(.c) void,
    hy_gfx_modelImport: *const fn (gpu: *hy.gfx.Gpu, path: hy.ExternSliceConst(u8), settings: hy.gfx.ImportSettings) callconv(.c) hy.gfx.Model,
    hy_gfx_modelCreate: *const fn (gpu: *hy.gfx.Gpu, opts: hy.gfx.ModelCreateOptions) callconv(.c) hy.gfx.Model,
    hy_gfx_modelDupe: *const fn (gpu: *hy.gfx.Gpu, original_model: hy.gfx.Model, options: hy.gfx.ModelDupeOptions) callconv(.c) hy.gfx.Model,
    hy_gfx_modelDestroy: *const fn (gpu: *hy.gfx.Gpu, model: hy.gfx.Model) callconv(.c) void,
    hy_gfx_modelBounds: *const fn (gpu: *hy.gfx.Gpu, model: hy.gfx.Model) callconv(.c) hym.AxisAligned,
    hy_gfx_modelPrimitive: *const fn (gpu: *hy.gfx.Gpu, shape: hy.gfx.PrimitiveShape) callconv(.c) hy.gfx.Model,
    hy_gfx_modelMaterial: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.Model) callconv(.c) hy.gfx.MaterialHandle,
    hy_gfx_modelWaitLoad: *const fn (gpu: *hy.gfx.Gpu, model: hy.gfx.Model, max: u64) callconv(.c) bool,
    hy_gfx_materialLoad: *const fn (gpu: *hy.gfx.Gpu, path: hy.ExternSliceConst(u8)) callconv(.c) hy.gfx.MaterialHandle,
    hy_gfx_materialReload: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.MaterialHandle) callconv(.c) void,
    hy_gfx_materialCreate: *const fn (gpu: *hy.gfx.Gpu, opts: hy.gfx.MaterialCreateOptions) callconv(.c) hy.gfx.MaterialHandle,
    hy_gfx_materialDupe: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.MaterialHandle) callconv(.c) hy.gfx.MaterialHandle,
    hy_gfx_materialDestroy: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.MaterialHandle) callconv(.c) void,
    hy_gfx_renderableAdd: *const fn (gpu: *hy.gfx.Gpu, options: hy.gfx.AddRenderableOptions) callconv(.c) hy.gfx.Renderable,
    hy_gfx_renderableRemove: *const fn (gpu: *hy.gfx.Gpu, item: hy.gfx.Renderable) callconv(.c) void,
    hy_gfx_renderableTransformSet: *const fn (gpu: *hy.gfx.Gpu, item: hy.gfx.Renderable, transform: hym.Mat4) callconv(.c) void,
    hy_gfx_spriteCreate: *const fn (gpu: *hy.gfx.Gpu, opts: hy.gfx.SpriteCreateOptions) callconv(.c) hy.gfx.Model,
    hy_gfx_spriteDestroy: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.Model) callconv(.c) void,
    hy_gfx_spriteWeakPtr: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.Sprite.Handle) callconv(.c) ?*hy.gfx.Sprite,
    hy_gfx_spriteRenderableWeakPtr: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.Renderable) callconv(.c) ?*hy.gfx.Sprite,
    hy_gfx_spriteCurrentAnimationFrame: *const fn (gpu: *hy.gfx.Gpu, sprite: *hy.gfx.Sprite) callconv(.c) u32,
    hy_gfx_spriteDupe: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.Model) callconv(.c) hy.gfx.Model,
    hy_gfx_textureImport: *const fn (gpu: *hy.gfx.Gpu, path: hy.ExternSliceConst(u8)) callconv(.c) hy.gfx.TextureHandle,
    hy_gfx_passCreate: *const fn (gpu: *hy.gfx.Gpu, opts: hy.gfx.PassCreateOptions) callconv(.c) hy.gfx.PassHandle,
    hy_gfx_passDestroy: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.PassHandle) callconv(.c) void,
    hy_gfx_passAdd: *const fn (gpu: *hy.gfx.Gpu, opts: hy.gfx.PassAddOptions) callconv(.c) hy.gfx.Renderable,
    hy_gfx_passClear: *const fn (gpu: *hy.gfx.Gpu, hdl: hy.gfx.PassHandle) callconv(.c) void,
    hy_gfx_immediateDraw: *const fn (gpu: *hy.gfx.Gpu, verts: hy.ExternSliceConst(hy.gfx.UIVertex), indices: hy.ExternSliceConst(u32), transform: hym.Mat4, material_hdl: hy.gfx.MaterialHandle) callconv(.c) void,
    hy_gfx_immediateText: *const fn (
        gpu: *hy.gfx.Gpu,
        glyphs: hy.ExternSliceConst(u8),
        transform: hym.Mat4,
        color: u32,
    ) callconv(.c) void,
    hy_io_reset: *const fn (input: *hy.input.Context) callconv(.c) void,
    hy_io_mouse: *const fn (input: *hy.input.Context, button: hy.key.MouseButton) callconv(.c) bool,
    hy_io_mousePosition: *const fn (input: *hy.input.Context) callconv(.c) hym.Vec2,
    hy_io_key: *const fn (input: *hy.input.Context, button: hy.key.Keycode) callconv(.c) bool,
    hy_io_bindPoll: *const fn (input: *hy.input.Context, id: u32, on: hy.input.OnFlags, button: hy.key.Keycode) callconv(.c) void,
    hy_io_bindPollMouse: *const fn (input: *hy.input.Context, id: u32, on: hy.input.OnFlags, mouse: hy.MouseButton) callconv(.c) void,
    hy_io_eventPump: *const fn (input: *hy.input.Context) callconv(.c) hy.ExternSliceConst(u32),
    hy_io_eventClear: *const fn (input: *hy.input.Context, events: hy.ExternSliceConst(u32)) callconv(.c) void,
    hy_p2_reset: *const fn (p2_ctx: *hy.p2.Context) callconv(.c) void,
    hy_p2_bodyAdd: *const fn (p2_ctx: *hy.p2.Context, opts: *const hy.p2.BodyAddOptions) callconv(.c) hy.p2.Body,
    hy_p2_bodyValid: *const fn (body: hy.p2.Body) callconv(.c) bool,
    hy_p2_bodyShapeAdd: *const fn (body: hy.p2.Body, opts: *const hy.p2.BodyAddOptions.ShapeOptions) callconv(.c) void,
    hy_p2_bodyDestroy: *const fn (body: hy.p2.Body) callconv(.c) void,
    hy_p2_bodyUserData: *const fn (body: hy.p2.Body) callconv(.c) ?*anyopaque,
    hy_p2_bodyUserDataSet: *const fn (body: hy.p2.Body, user_data: ?*anyopaque) callconv(.c) void,
    hy_p2_bodyPosition: *const fn (p2_ctx: *hy.p2.Context, body: hy.p2.Body) callconv(.c) hym.Vec2,
    hy_p2_bodyPositionSet: *const fn (body: hy.p2.Body, pos: hym.Vec2) callconv(.c) void,
    hy_p2_bodyPositionReal: *const fn (body: hy.p2.Body) callconv(.c) hym.Vec2,
    hy_p2_bodyType: *const fn (body: hy.p2.Body) callconv(.c) hy.p2.Body.Type,
    hy_p2_bodyTypeSet: *const fn (body: hy.p2.Body, body_type: hy.p2.Body.Type) callconv(.c) void,
    hy_p2_bodyVelocity: *const fn (body: hy.p2.Body) callconv(.c) hym.Vec2,
    hy_p2_bodyVelocitySet: *const fn (body: hy.p2.Body, velocity: hym.Vec2) callconv(.c) void,
    hy_p2_shapeExtra: *const fn (shape: hy.p2.Shape) callconv(.c) hy.p2.ShapeExtra,
    hy_p2_eventPump: *const fn (p2_ctx: *hy.p2.Context, buffer: hy.ExternSlice(u8)) callconv(.c) u32,
    hy_p2_overlapLeaky: *const fn (p2_ctx: *hy.p2.Context, arena: hy.ExternAllocator, shape: *const hy.p2.ShapeConfig, origin: hym.Vec2) callconv(.c) hy.ExternSlice(hy.p2.Shape),
    hy_p2_castRayLeaky: *const fn (p2_ctx: *hy.p2.Context, arena: hy.ExternAllocator, opts: hy.p2.RaycastOptions) callconv(.c) hy.ExternSlice(hy.p2.RaycastHit),
    hy_p2_castCircleLeaky: *const fn (p2_ctx: *hy.p2.Context, arena: hy.ExternAllocator, opts: hy.p2.CastCircleOptions) callconv(.c) hy.ExternSlice(hy.p2.RaycastHit),
    hy_p2_shapeBody: *const fn (shape: hy.p2.Shape) callconv(.c) hy.p2.Body,
    hy_p2_shapeValid: *const fn (shape: hy.p2.Shape) callconv(.c) bool,
    hy_ui_globalState: *const fn (ui: *hy.UI) callconv(.c) hy.ui.State,
    hy_ui_inputState: *const fn (ui: *hy.UI) callconv(.c) hy.ui.InputState,
    hy_win_relativeMouseMode: *const fn (window: *hy.Window, on_off: bool) callconv(.c) void,
    hy_win_dimensions: *const fn (window: *hy.Window) callconv(.c) hym.Vec2,
    hy_win_projectionMatrix: *const fn (window: *hy.Window) callconv(.c) hym.Mat4,
};

pub var table: ProcTable = undefined;
